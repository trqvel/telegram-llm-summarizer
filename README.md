# Отчет о проекте "Суммаризация сообщений с помощью LLM групп Telegram"

## Содержание
1. Введение
2. Архитектура проекта
   2.1. Общая структура
   2.2. Технологический стек
   2.3. Файловая структура
3. Фаза ETL данных
   3.1. Извлечение данных из Telegram API
   3.2. Трансформация и очистка сообщений
   3.3. Загрузка данных в хранилище
   3.4. Автоматизация ETL процесса
4. Фаза аналитики и машинного обучения
   4.1. Анализ тональности сообщений
   4.2. Суммаризация сообщений с использованием LLM
   4.3. Генерация RSS-потоков
5. Фаза визуализации
   5.1. Структура пользовательского интерфейса
   5.2. Аутентификация и управление профилем
   5.3. Панель статистики и визуализации
   5.4. Управление группами Telegram
6. Взаимодействие компонентов системы
   6.1. Процесс получения и обработки данных
   6.2. Генерация и обновление аналитики
   6.3. Представление результатов пользователю
7. Настройка и запуск
   7.1. Необходимые зависимости
   7.2. Настройка окружения
   7.3. Подключение к группам Telegram
   7.4. Запуск приложения
8. Заключение

## 1. Введение

Проект "Суммаризация сообщений с помощью LLM групп Telegram" представляет собой комплексное решение для анализа сообщений в группах Telegram с использованием современных методов обработки естественного языка и машинного обучения. Система позволяет автоматически собирать сообщения из групп Telegram, анализировать их тональность, создавать краткие смысловые сводки и представлять полученные результаты в виде интерактивных графиков и RSS-потоков.

Основные возможности системы включают:
- Автоматический сбор сообщений из выбранных групп Telegram в режиме реального времени
- Очистка и нормализация текстовых данных (удаление HTML, эмодзи и других нерелевантных элементов)
- Анализ тональности сообщений (положительная, отрицательная, нейтральная)
- Генерация кратких резюме длинных обсуждений с использованием больших языковых моделей (LLM)
- Визуализация активности пользователей и изменений тональности с течением времени
- Формирование RSS-потоков для мониторинга активности в группах
- Система аутентификации и управления пользовательскими профилями

Проект реализован на языке программирования R с использованием фреймворка Shiny для создания веб-интерфейса, библиотеки telegram.bot для взаимодействия с API Telegram, а также инструментов машинного обучения для анализа и обработки текстов.

## 2. Архитектура проекта

### 2.1. Общая структура

Архитектура проекта основана на модульном принципе и разделена на следующие основные компоненты:

1. **Модуль сбора данных** - отвечает за взаимодействие с API Telegram и получение сообщений из групп.
2. **ETL-процесс** - включает извлечение, трансформацию и загрузку данных в базу данных.
3. **Модуль аналитики** - реализует анализ тональности и суммаризацию сообщений с использованием LLM.
4. **Модуль визуализации** - обеспечивает представление результатов в виде интерактивного веб-интерфейса.
5. **Генератор RSS** - формирует RSS-потоки на основе обработанных данных.
6. **База данных** - хранит исходные сообщения, результаты анализа и метаданные.
7. **API-сервис** - предоставляет программный доступ к функциональности системы.

Компоненты взаимодействуют между собой следующим образом:
- Модуль сбора данных периодически опрашивает API Telegram и сохраняет полученные сообщения в базу данных.
- ETL-процесс обрабатывает и нормализует сырые данные для дальнейшего анализа.
- Модуль аналитики применяет алгоритмы машинного обучения к очищенным данным.
- Результаты анализа сохраняются в базу данных и доступны через модуль визуализации и RSS-генератор.

### 2.2. Технологический стек

В проекте используются следующие технологии и библиотеки:

- **R** - основной язык программирования
- **Shiny** - фреймворк для создания веб-приложений на R
- **telegram.bot** - библиотека для работы с Telegram Bot API
- **RPostgres/DBI** - для взаимодействия с базой данных PostgreSQL
- **dplyr, stringr, lubridate** - для обработки и манипуляции данными
- **huggingfaceR** - для использования моделей машинного обучения от HuggingFace
- **openssl, sodium** - для шифрования и хеширования паролей
- **jsonlite** - для работы с JSON
- **shinydashboard** - для создания интерактивных дашбордов
- **DT** - для интерактивных таблиц в веб-интерфейсе
- **future, parallelly** - для асинхронного выполнения задач

База данных PostgreSQL используется для хранения данных из-за её надежности, производительности и поддержки сложных запросов.

### 2.3. Файловая структура

Проект организован в соответствии со следующей структурой каталогов:

```
telegram-llm-summarizer/
├── .env                   # Файл с переменными окружения
├── cmd/                   # Командные сценарии
│   └── app/
│       └── main.R         # Главный файл запуска приложения
├── src/                   # Исходный код
│   ├── app/               # Код веб-приложения Shiny
│   │   ├── app.R          # Определение UI и серверной части приложения
│   │   ├── auth.R         # Модуль аутентификации
│   │   ├── profile.R      # Модуль управления профилем пользователя
│   │   └── reg.R          # Модуль регистрации
│   ├── db/                # Код для работы с базой данных
│   │   ├── connection_db.R # Функции для подключения к БД
│   │   └── etl/           # ETL-процессы
│   │       ├── extract_data.R  # Извлечение данных
│   │       ├── transform_data.R # Трансформация данных
│   │       └── load_data.R     # Загрузка обработанных данных
│   ├── llm/               # Модели машинного обучения
│   │   └── openai/        # Интеграции с OpenAI
│   │       ├── sentiment.R  # Анализ тональности
│   │       ├── summarize.R  # Суммаризация текста
│   │       └── gen_rss.R    # Генерация RSS
│   └── telegram/          # Код для взаимодействия с Telegram
│       ├── get_msgs.R     # Получение сообщений
│       └── handlers/      # Обработчики событий Telegram
│           └── msg_handler.R # Обработчик сообщений
```

## 3. Фаза ETL данных

Фаза ETL (Extract, Transform, Load) является ключевой для функционирования всей системы и обеспечивает сбор, обработку и хранение данных из Telegram.

### 3.1. Извлечение данных из Telegram API

Извлечение данных из Telegram API реализовано в нескольких файлах:

1. **src/telegram/get_msgs.R** - основной файл для прямого получения сообщений от Telegram Bot API. Этот скрипт:
   - Устанавливает подключение к API Telegram с использованием библиотеки telegram.bot
   - Удаляет webhook для использования long polling
   - Получает последние сообщения через метод getUpdates
   - Сохраняет полученные сообщения в таблицу raw_msgs в базе данных
   - Обрабатывает ошибки подключения и преобразования данных
   - Логирует процесс получения и сохранения сообщений

2. **src/telegram/handlers/msg_handler.R** - файл с обработчиком сообщений, который:
   - Регистрирует обработчик для автоматической обработки входящих сообщений
   - Проверяет наличие необходимых таблиц в базе данных и создает их при необходимости
   - Извлекает релевантные данные из сообщений (текст, ID чата, информация о пользователе)
   - Преобразует данные в JSON для хранения
   - Сохраняет данные в таблицу raw_msgs с проверкой наличия столбца processed

3. **src/db/etl/extract_data.R** - файл для извлечения необработанных сообщений из базы данных:
   - Проверяет структуру таблицы raw_msgs и добавляет отсутствующие столбцы
   - Запрашивает необработанные сообщения (с флагом processed=FALSE)
   - Парсит JSON-структуру сообщений для дальнейшей обработки
   - Логирует процесс извлечения и количество найденных сообщений

Процесс извлечения данных настроен для автоматического выполнения с регулярными интервалами через планировщик, реализованный в файле cmd/app/main.R с использованием пакета future.

Пример кода извлечения обновлений из Telegram API:
```r
updates <- tryCatch({
  bot$getUpdates(limit = 10, timeout = 10)
}, error = function(e) {
  message(paste("ОШИБКА при получении обновлений:", e$message))
  list()
})
```

### 3.2. Трансформация и очистка сообщений

Трансформация и очистка данных реализованы в файле src/db/etl/transform_data.R, который выполняет следующие операции:

1. Создание структуры таблицы clean_msgs для хранения очищенных данных
2. Выборка сырых сообщений из таблицы raw_msgs, которые еще не были обработаны
3. Парсинг JSON-структуры каждого сообщения
4. Извлечение необходимых полей: ID обновления, ID чата, название чата, ID пользователя, имя пользователя, время сообщения и текст
5. Очистка текста от HTML-тегов, URL, эмодзи и других нерелевантных элементов
6. Нормализация текста (удаление лишних пробелов, приведение к единому формату)
7. Сохранение очищенных данных в таблицу clean_msgs
8. Обновление флага processed в таблице raw_msgs для обработанных сообщений

Очистка текста осуществляется с помощью библиотек stringr и stringi, которые предоставляют мощные инструменты для обработки строк. Особое внимание уделяется удалению эмодзи, которые могут исказить результаты анализа тональности и суммаризации.

Пример кода очистки текста:
```r
text_clean = str_squish(
    stringi::stri_replace_all_regex(
        str_remove_all(str_remove_all(m$text, "<[^>]+>"), "https?://\\S+"),
        "\\p{Emoji}", ""
    )
)
```

### 3.3. Загрузка данных в хранилище

Загрузка обработанных данных в хранилище реализована в файле src/db/etl/load_data.R, который:

1. Устанавливает соединение с базой данных
2. Создает таблицу processed_messages для отслеживания обработанных сообщений
3. Вставляет ID обработанных сообщений в таблицу processed_messages
4. Обновляет статус обработки для записей в raw_msgs

Система использует несколько таблиц для хранения данных на разных этапах обработки:
- **raw_msgs** - сырые сообщения в формате JSON, полученные от Telegram API
- **clean_msgs** - очищенные и структурированные сообщения
- **sentiments** - результаты анализа тональности сообщений
- **summaries** - сгенерированные краткие сводки сообщений
- **user_groups** - информация о группах Telegram, за которыми следит система
- **users** - информация о пользователях системы

Загрузка данных реализована с использованием транзакций для обеспечения целостности данных в случае сбоев.

### 3.4. Автоматизация ETL процесса

Автоматизация ETL-процесса реализована в файле cmd/app/main.R, который настраивает периодическое выполнение ETL-операций с использованием пакета future:

```r
future({
  repeat {
    source(file.path(root_dir, "src/db/etl/extract_data.R"))
    source(file.path(root_dir, "src/db/etl/transform_data.R"))
    source(file.path(root_dir, "src/db/etl/load_data.R"))
    source(file.path(root_dir, "src/llm/openai/sentiment.R"))
    source(file.path(root_dir, "src/llm/openai/summarize.R"))
    source(file.path(root_dir, "src/llm/openai/gen_rss.R"))
    Sys.sleep(600)
  }
}, seed = FALSE)
```

Этот код выполняется в отдельном потоке и запускает цикл ETL-процесса каждые 10 минут (600 секунд). В каждой итерации выполняются следующие шаги:
1. Извлечение новых необработанных сообщений
2. Трансформация и очистка этих сообщений
3. Загрузка очищенных данных
4. Выполнение анализа тональности
5. Генерация суммаризаций
6. Обновление RSS-потоков

Параллельно с этим в отдельном потоке выполняется постоянный опрос Telegram API для получения новых сообщений.

## 4. Фаза аналитики и машинного обучения

Фаза аналитики и машинного обучения включает в себя анализ тональности сообщений, их суммаризацию и генерацию RSS-потоков на основе обработанных данных.

### 4.1. Анализ тональности сообщений

Анализ тональности сообщений реализован в файле src/llm/openai/sentiment.R, который:

1. Загружает очищенные сообщения из таблицы clean_msgs, которые еще не были проанализированы
2. Применяет модель анализа тональности к каждому сообщению
3. Определяет эмоциональную окраску сообщения (положительная, отрицательная, нейтральная)
4. Сохраняет результаты в таблицу sentiments
5. Отмечает проанализированные сообщения

Для анализа тональности используется модель из библиотеки huggingfaceR, которая позволяет обрабатывать тексты на русском языке. Система классифицирует сообщения по трем категориям:
- Положительные (positive)
- Отрицательные (negative)
- Нейтральные (neutral)

Для каждой категории вычисляется числовая оценка уверенности (confidence score) в диапазоне от 0 до 1. Сообщение относится к той категории, по которой получена наивысшая оценка.

Результаты анализа тональности используются для построения графиков изменения настроений в группе с течением времени, что позволяет отслеживать реакцию участников на различные события.

### 4.2. Суммаризация сообщений с использованием LLM

Суммаризация сообщений реализована в файле src/llm/openai/summarize.R, который:

1. Группирует сообщения по временным интервалам (например, ежедневно или еженедельно)
2. Формирует набор сообщений для каждого интервала
3. Применяет большую языковую модель для создания краткого резюме этих сообщений
4. Сохраняет сгенерированные резюме в таблицу summaries

Для суммаризации используются современные модели NLP, такие как GPT (через API OpenAI) или локально развернутые модели через библиотеку huggingfaceR. Система формирует запрос к модели, включающий контекст группы, временной период и сами сообщения, а затем получает сгенерированное резюме.

Преимущества использования LLM для суммаризации:
- Способность выделять ключевые темы и идеи из большого объема текста
- Генерация связного и грамматически правильного текста
- Адаптация к специфической терминологии и контексту группы
- Возможность настройки стиля и формата суммаризации

Система также позволяет настраивать параметры суммаризации, такие как максимальная длина резюме, стиль (формальный/неформальный) и фокус на определенных типах информации.

### 4.3. Генерация RSS-потоков

Генерация RSS-потоков реализована в файле src/llm/openai/gen_rss.R, который:

1. Формирует RSS-каналы для каждой отслеживаемой группы Telegram
2. Включает в RSS-потоки суммаризированные данные и результаты анализа тональности
3. Генерирует XML-структуру в соответствии со спецификацией RSS 2.0
4. Сохраняет RSS-файлы для доступа через веб-интерфейс

RSS-потоки обновляются автоматически при появлении новых суммаризаций и позволяют пользователям следить за активностью групп через любой RSS-агрегатор.

Структура RSS-канала включает:
- Заголовок канала (название группы Telegram)
- Описание канала
- Ссылку на группу
- Элементы (items), соответствующие суммаризациям за различные временные периоды
- Метаданные, включая результаты анализа тональности и активности

## 5. Фаза визуализации

Фаза визуализации обеспечивает представление результатов анализа в виде интерактивного веб-интерфейса, построенного с использованием фреймворка Shiny.

### 5.1. Структура пользовательского интерфейса

Основная структура пользовательского интерфейса определена в файле src/app/app.R, который:

1. Задает макет приложения с использованием shinydashboard
2. Определяет основные разделы интерфейса:
   - Секция авторизации/регистрации
   - Настройки профиля
   - Управление группами Telegram
   - Просмотр статистики и визуализаций
   - Доступ к RSS-потокам
3. Инициализирует соединение с базой данных и необходимые таблицы
4. Определяет серверную логику для обработки пользовательских взаимодействий

Интерфейс разработан в соответствии с принципами отзывчивого дизайна и адаптируется к различным размерам экрана. Для навигации по разделам используется боковое меню, а основной контент отображается в центральной части экрана.

### 5.2. Аутентификация и управление профилем

Аутентификация и управление профилем реализованы в файлах:

1. **src/app/auth.R** - модуль аутентификации, который:
   - Отображает форму входа с полями для логина и пароля
   - Проверяет учетные данные пользователя в базе данных
   - Защищает пароли с использованием хеширования SHA-256 с солью
   - Управляет сессиями пользователей
   - Отображает сообщения об ошибках при неудачной аутентификации

2. **src/app/reg.R** - модуль регистрации, который:
   - Предоставляет форму для создания новых учетных записей
   - Проверяет уникальность имени пользователя
   - Хеширует пароли перед сохранением в базу данных
   - Создает необходимые записи в таблице users

3. **src/app/profile.R** - модуль управления профилем, который:
   - Позволяет пользователям просматривать и изменять личную информацию
   - Обеспечивает функциональность смены пароля
   - Обновляет информацию в базе данных
   - Включает валидацию вводимых данных для обеспечения безопасности

Система аутентификации использует современные практики безопасности, включая:
- Хеширование паролей с использованием соли
- Защиту от SQL-инъекций с помощью параметризованных запросов
- Защиту от атак подбора паролей через ограничение числа попыток входа
- Безопасное хранение сессионных данных

### 5.3. Панель статистики и визуализации

Панель статистики и визуализации реализована в src/app/app.R и предоставляет следующие возможности:

1. Отображение общей статистики для выбранной группы:
   - Количество сообщений за выбранный период
   - Число активных пользователей
   - Распределение тональности сообщений (положительная/отрицательная/нейтральная)
   - Средняя длина сообщений

2. Графики и визуализации:
   - График изменения активности с течением времени
   - Диаграмма распределения тональности сообщений
   - Облако тегов для ключевых слов и тем
   - График активности отдельных участников

3. Фильтры и настройки:
   - Выбор временного интервала (день, неделя, месяц)
   - Фильтрация по участникам
   - Фильтрация по темам или ключевым словам
   - Выбор типа визуализации

Для визуализации используются различные типы графиков, реализованные с помощью библиотек plotly и ggplot2, которые интегрируются с Shiny для создания интерактивных визуализаций.

### 5.4. Управление группами Telegram

Управление группами Telegram реализовано в файле src/app/app.R и включает:

1. Интерфейс для добавления новых групп:
   - Поле для ввода идентификатора или ссылки на группу
   - Подсказки по формату идентификаторов групп
   - Кнопка для добавления группы

2. Список отслеживаемых групп с возможностью:
   - Просмотра основной информации (название, количество участников)
   - Удаления группы из списка отслеживаемых
   - Настройки параметров сбора данных для группы

3. Механизм проверки прав доступа бота к группе:
   - Верификация добавления бота в группу в качестве администратора
   - Проверка необходимых разрешений для чтения сообщений
   - Отображение статуса подключения к группе

Система работает с группами через таблицу user_groups, которая хранит связи между пользователями системы и группами Telegram, за которыми они следят.

## 6. Взаимодействие компонентов системы

### 6.1. Процесс получения и обработки данных

Полный цикл получения и обработки данных включает следующие этапы:

1. Запуск приложения (cmd/app/main.R)
2. Инициализация соединения с Telegram Bot API
3. Запуск двух асинхронных процессов:
   - Получение обновлений от Telegram API
   - Выполнение ETL-процессов

4. Процесс получения обновлений:
   - Периодическое обращение к методу getUpdates
   - Обработка полученных сообщений через msg_handler
   - Сохранение сырых данных в таблицу raw_msgs

5. ETL-процесс:
   - extract_data.R извлекает необработанные сообщения
   - transform_data.R очищает и структурирует данные
   - load_data.R отмечает сообщения как обработанные

6. Процессы анализа:
   - sentiment.R анализирует тональность сообщений
   - summarize.R генерирует суммаризации
   - gen_rss.R обновляет RSS-потоки

7. Обновление пользовательского интерфейса с новыми данными через реактивные механизмы Shiny

### 6.2. Генерация и обновление аналитики

Процесс генерации и обновления аналитики включает:

1. Сбор данных из таблицы clean_msgs за выбранный период
2. Применение алгоритмов анализа тональности к каждому сообщению
3. Группировка сообщений по временным интервалам
4. Генерация суммаризаций для каждого интервала с использованием LLM
5. Вычисление статистических показателей:
   - Средние значения тональности
   - Распределение активности по времени
   - Идентификация наиболее активных участников
   - Выделение ключевых тем и терминов
6. Сохранение результатов в соответствующие таблицы
7. Обновление RSS-потоков с новой аналитикой

Аналитические данные кэшируются для повышения производительности и обновляются при появлении новых сообщений, превышающих определенный порог.

### 6.3. Представление результатов пользователю

Процесс представления результатов пользователю включает:

1. Аутентификация пользователя через модуль auth.R
2. Загрузка пользовательских настроек и списка отслеживаемых групп
3. Формирование пользовательского интерфейса с доступными разделами
4. Обработка пользовательских взаимодействий
5. Динамическая генерация визуализаций на основе выбранных параметров
6. Формирование RSS-потоков для внешнего доступа
7. Обновление отображаемых данных при изменении выбранных параметров или появлении новой информации

Пользовательский интерфейс реагирует на изменения данных в реальном времени благодаря реактивным механизмам Shiny.

## 7. Настройка и запуск

### 7.1. Необходимые зависимости

Для работы проекта необходимы следующие R-пакеты:

```r
need <- c(
  "telegram.bot", "future", "parallelly", "DBI", "RPostgres",
  "dplyr", "stringr", "stringi", "lubridate", "jsonlite",
  "huggingfaceR", "xml2", "shiny", "shinydashboard", "sodium", "DT",
  "openssl"
)
```

Вы можете установить их с помощью следующей команды в R:

```r
install.packages(c("telegram.bot", "future", "parallelly", "DBI", "RPostgres",
                  "dplyr", "stringr", "stringi", "lubridate", "jsonlite",
                  "xml2", "shiny", "shinydashboard", "sodium", "DT",
                  "openssl"))

remotes::install_github("farewellXD/huggingfaceR")
```

### 7.2. Настройка окружения

1. **Клонирование репозитория**:
   ```bash
   git clone <repository_url>
   cd telegram-llm-summarizer
   ```

2. **Создание файла окружения**:
   Создайте файл `.env` в корневой директории проекта со следующими параметрами:
   ```
   TELEGRAM_BOT_TOKEN=ваш_токен_бота
   HF_API_TOKEN=ваш_токен_huggingface
   DB_HOST=localhost
   DB_PORT=5432
   DB_USER=postgres
   DB_PASS=ваш_пароль
   DB_NAME=postgres
   ```

3. **Настройка базы данных**:
   - Установите PostgreSQL и создайте базу данных
   - Убедитесь, что параметры подключения в `.env` соответствуют вашей конфигурации

### 7.3. Подключение к группам Telegram

1. Создайте бота через [@BotFather](https://t.me/BotFather) и получите токен
2. Добавьте бота в нужную группу как администратора с правами чтения сообщений
3. Добавьте группу через веб-интерфейс, используя ID группы или ссылку

### 7.4. Запуск приложения

1. **Запуск основного приложения**:
   ```bash
   Rscript cmd/app/main.R
   ```
   Это запустит Shiny-приложение на `http://127.0.0.1:3838` и инициализирует процессы получения и обработки сообщений.

2. **Проверка получения сообщений**:
   ```bash
   Rscript src/telegram/get_msgs.R
   ```
   Этот скрипт позволяет проверить, что бот может получать сообщения из групп Telegram.

## 8. Заключение

Проект "Суммаризация сообщений с помощью LLM групп Telegram" представляет собой комплексное решение для автоматизированного анализа и обработки сообщений из групп Telegram. Система успешно решает задачи сбора данных, их очистки, анализа тональности, суммаризации и визуализации результатов.

Основные достижения проекта:

1. Реализация полного ETL-процесса для данных из Telegram API
2. Применение современных методов обработки естественного языка для анализа тональности и суммаризации сообщений
3. Создание интерактивного веб-интерфейса для работы с аналитическими данными
4. Автоматическая генерация RSS-потоков для мониторинга активности в группах
5. Реализация многоуровневой архитектуры с четким разделением ответственности между компонентами

Система демонстрирует эффективность применения больших языковых моделей для решения практических задач анализа и суммаризации текста, а также возможности современных инструментов визуализации данных.

Примечание: Данный отчет можно экспортировать в формат Word, добавить оглавление, форматирование и при необходимости дополнить скриншотами или диаграммами для визуализации описанных процессов.

